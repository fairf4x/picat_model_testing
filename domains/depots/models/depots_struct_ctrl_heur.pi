% by Roman Bartak, 2015
import planner.
import util.

solve_all =>
	all(Benches),nl,
	foreach(Bench in Benches)
		write(Bench), print(": "), once(call(Bench))
	end.

pddl(IFacts,GFacts) => 
	initialize_table,
	PaletLocations = [Fact : Fact in IFacts, (Fact = $at(Palet,_),
						 (member($clear(Palet),IFacts); member($on(_,Palet),IFacts)),
						 not member($on(Palet,_),IFacts))],	 		
	Trucks = sort([{[],Loc} : $at(T,Loc) in IFacts, (not member($on(_,T),IFacts),
							not member($clear(T),IFacts),
							not member($available(T),IFacts))]),
	Hoists = sort([{[],Loc} : $at(T,Loc) in IFacts, member($available(T),IFacts)]),
	Towers = sort([T : $at(Palet,_) in PaletLocations, tower([Palet],IFacts,T)]), 
	cl_facts(PaletLocations++GFacts,[]),
%	plan({Towers,Hoists,Trucks},99999999,Plan,PlanCost),
	statistics(runtime,RTB),
	###PLANNER###({Towers,Hoists,Trucks},99999999,Plan,PlanCost),
	statistics(runtime,RTA),
  printf("%d,%d!%n",PlanCost,RTA[2]).

% build a tower based on input data
tower(T1@[X|_],IFacts,T),
  member($on(Y,X),IFacts) =>
	tower([Y|T1],IFacts,T).
tower(T@[X|_],IFacts,T1),
  member($clear(X),IFacts) =>
  	T1 = T.

% tower is good if nothing should be changed in it
table
good_tower(Tower),
	Tower = [_]
=>
	true.
good_tower(Tower),
	Tower = [X,Y|T],
	(on(X,Y) ; (not on(X,_), not on(_,Y)))
=>
	good_tower([Y|T]).

% find a target location for a crate
% we assume that complete towers with pallets are specified in the goal
table
crate_loc(C,Loc), % location of palet
	at(C,Loc)
=> true.
crate_loc(C,Loc),
	on(C,C1)
=>
	crate_loc(C1,Loc).
	
% compute the lower bound for the number of steps to the goal
%  for each wrongly placed crate, it is one step, if the crate is hold by a hoist
%   otherwise we need two steps (pick up and drop off)
moves2go(Towers,Hoists) = 
	sum(findall(Cost, (on(X,Y),
							not (member(T,Towers),nextto(X,Y,T)),
							simple_cost(X,Hoists,Cost)))).
simple_cost(X,Hoists,Cost),  % some hoist is holding crate X
	member({[X],_}, Hoists)
=>
	Cost = 1.
simple_cost(_X,_Hoists,Cost)
=>
	Cost = 2.
	
final(_) ?=>
  Plan = current_plan(),
  current_resource_plan_cost(_Amount,Plan,Cost),
  if Cost == 0 then
    statistics(runtime,RT),
    printf("%d,%d;",Cost,RT[2]),flush(stdout)
  end,fail.

% finish when all towers are build
final({Towers,_Hoists,_Trucks}) =>
	foreach([A|B] in findall([X|Y], on(X,Y)))
		member(T,Towers),nextto(A,B,T)
	end.

%action(S,NS,A,C) ?=> writeln(S),fail.

% DROP crate to a tower where it belongs
action({Towers,Hoists,Trucks},NextState,Action,ActionCost),
	select({[C],Loc},Hoists,Hoists1),  % select a hoist at location Loc holding some crate
	select(T,Towers,Towers1),	% select a tower
	Pallet = last(T),			%   extract pallet of the tower
	at(Pallet,Loc),				%   ensure that the tower is at location of the hoist
	good_tower([C|T])			% tower is good after putting C on it
=>
	Action = $drop(C,Pallet,Loc),
	ActionCost = 1,
	NextState = {sort([[C|T]|Towers1]),sort([{[],Loc}|Hoists1]),Trucks}.

% LIFT a crate only from a bad tower
action({Towers,Hoists,Trucks},NextState,Action,ActionCost),
	select(T,Towers,Towers1),	% select a tower
	not good_tower(T),			%  that is not good
	Pallet = last(T),			% find the name of pallet in the tower
	at(Pallet,Loc),				% find location of the pallet
	select({[],Loc},Hoists,Hoists1),  % select empty hoist at location Loc
	T = [C|T1]					% C is a top crate to be moved
=>
	Action = $lift(C,Pallet,Loc),
	ActionCost = 1,
	NextState = {sort([T1|Towers1]), sort([{[C],Loc}|Hoists1]), Trucks}.
	
% UNLOAD a crate from a truck only if the crate can be placed to a good tower
%  may not be optimal, if crate should be put to a different truck
action({Towers,Hoists,Trucks},NextState,Action,ActionCost),
	select({[],Loc},Hoists,Hoists1),  	% select empty hoist at location Loc to unload crate
	select({Load,Loc},Trucks,Trucks1),	% select a truck
	select(C,Load,Load1),				%   with a crate
	
	member(T,Towers),			% find a tower
	Pallet = last(T),			% find the name of pallet in the tower
	at(Pallet,Loc),				% find location of the pallet that must be Loc
	good_tower([C|T])			% C can be put on top of that tower
=>
	Action = $unload(C,Loc),
	ActionCost = 1,
	NextState = {Towers, sort([{[C],Loc}|Hoists1]), sort([{Load1,Loc}|Trucks1])},
	moves2go(Towers,[{[C],Loc}|Hoists1]) < current_resource().
	
% LOAD crate to a truck
action({Towers,Hoists,Trucks},NextState,Action,ActionCost),
	select({[C],Loc},Hoists,Hoists1),   % select a hoist at location Loc holding some crate
	select({Load,Loc},Trucks,Trucks1)	% select a truck at location Loc
?=>
	Action = $load(C,Loc),
	ActionCost = 1,
	NextState = {Towers, sort([{[],Loc}|Hoists1]), sort([{sort([C|Load]),Loc}|Trucks1])},
	moves2go(Towers,Hoists1) < current_resource().

% DRIVE truck to location where crate is waiting in hoist or some loaded crate should be moved there
action({Towers,Hoists,Trucks},NextState,Action,ActionCost),
	select({Load,Loc1},Trucks,Trucks1),	% select a truck at location Loc1
	(member({[_],Loc2},Hoists)			% any loaded hoist at location Loc2
	 ; member(C,Load), crate_loc(C,Loc2)), % or truck is loaded with crane to be at Loc2
	 Loc2 != Loc1
?=>
	Action = $drive(Loc1,Loc2),
	ActionCost = 1,
	NextState = {Towers, Hoists, sort([{Load,Loc2}|Trucks1])},
	moves2go(Towers,Hoists) < current_resource().
	
main([Bench]) =>
    P = Bench.to_atom(),
    call(P).
