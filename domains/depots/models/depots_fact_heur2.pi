import planner.

solve_all =>
        all(Benches),nl,
        foreach(Bench in Benches)
                write(Bench), print(": "), once(call(Bench))
        end.

pddl(IFacts,GFacts) =>
    	initialize_table,
	PaletLocations = [Fact : Fact in IFacts,
				(Fact = $at(Palet,_),
				(	member($clear(Palet),IFacts);
				 	member($on(_,Palet),IFacts)
				),
				not member($on(Palet,_),IFacts))],	
	% do we need unary predicates in order to enable typing? 	
	% list of trucks 
	Trucks = [ $truck(T) : 	$at(T,_) in IFacts,
					(not member($on(_,T),IFacts),
					 not member($clear(T),IFacts),
					 not member($available(T),IFacts),
           				 not member($lifting(T,_),IFacts)
          				)
		],
  	% writeln(Trucks),
 	% list of places
	Places = remove_dups([ $place(P) : $at(_,P) in IFacts]),
  	% writeln(Places),
 	% fact lists
	AtPred = sort([ [L|P] : $at(L,P) in IFacts]),
	OnPred = sort([ [C|S] : $on(C,S) in IFacts]),
	InPred = sort([ [C|T] : $in(C,T) in IFacts]),	
	LiftPred = sort([ [H|C] : $lifting(H,C) in IFacts]), 
	ClearList = sort([ S : $clear(S) in IFacts]), 
	AvailList = sort([ H : $available(H) in IFacts]),

	% load unary predicates and goal facts 
	cl_facts([$goal(GFacts)|Trucks++Places],[$goal(-),$truck(-),$place(-)]),
	cl_facts(GFacts,[]),
	%printState($s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred)), 
	statistics(runtime,RTB),
  ###PLANNER###($s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),99999,Plan,PlanCost),
  statistics(runtime,RTA),
  printf("%d,%d!%n",PlanCost,RTA[2]).

final(_) ?=>
  Plan = current_plan(),
  current_resource_plan_cost(_Amount,Plan,Cost),
  if Cost == 0 then
    statistics(runtime,RT),
    printf("%d,%d;",Cost,RT[2]),flush(stdout)
  end,fail.
  
% final predicate
final(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred)), goal(Goal),
	% all predicates from GFacts has to be listed
	foreach(G in Goal)
		(
			(G = $on(C,S), member([C|S],OnPred));
			(G = $at(L,P), member([L|P],AtPred));
			(G = $in(C,T), member([C|T],InPred));
			(G = $lifting(H,C), member([H|C],LiftPred));
			(G = $available(H), member(H,AvailList));
			(G = $clear(S), member(S,ClearList))
		)
	end => true.

/* --------- debugging ------------- */
printState(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred)) =>
        printf("clear: "),
        writeln(ClearList),
        printf("avail: "),
    	writeln(AvailList),
        printf("at: "),
        writeln(AtPred),
        printf("on: "),
        writeln(OnPred),
        printf("in: "),
        writeln(InPred),
        printf("lifting: "),
        writeln(LiftPred).

testAction(State,Action) =>
  printf("======== current state =====\n"),
  printState(State),
  printf("======== next state ========\n"),
  action(State,NState,Action,_),
  printState(NState),
  printf("======== action ========\n"),
  writeln(Action),
  printf("========================\n").
/* ----------------------- */

%%%%%%% heuristic %%%%%%%%

% compute the lower bound for the number of steps to the goal
% for each wrongly placed crate, it is one step, if the crate is hold by a hoist
% otherwise we need two steps (pick up and drop off)
moves2go(OnPred,LiftPred) = sum(X) =>
	X = findall(Cost, ( on(X,Y),
                      not (member([X|Y],OnPred)),
                      simple_cost(X,LiftPred,Cost)
                    )
              ).
  

simple_cost(X,LiftPred,Cost),
    member([_H|X],LiftPred)
=>
  Cost = 1.

simple_cost(_X,_LiftPred,Cost)
=>
  Cost = 2.
  
  
action(s(_ClearList,_AvailList,_AtPred,OnPred,_InPred,LiftPred),_,_,_),
	moves2go(OnPred,LiftNext) >= current_resource()
=>
	fail.

%%%%%%% operators %%%%%%%%

%(:action Drop 
%:parameters (?x - hoist ?y - crate ?z - surface ?p - place)                           
%:precondition (and (at ?x ?p) (at ?z ?p) (clear ?z) (lifting ?x ?y))                  
%:effect (and (available ?x) (not (lifting ?x ?y)) (at ?y ?p) (not (clear ?z)) (clear ?y)
%                (on ?y ?z)))                                                          
action(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),NextState,Action,ActionCost),
  select([X|Y],LiftPred,LiftRest),
  member([X|P],AtPred),
  member([Z|P],AtPred),
  select(Z,ClearList,ClearRest)
?=>
  ClearListNext = insert_ordered(ClearRest,Y),
  AtPredNext = insert_ordered(AtPred,[Y|P]),
  OnPredNext = insert_ordered(OnPred,[Y|Z]),
  AvailNext = insert_ordered(AvailList,X),
  Action = $drop(X,Y,Z,P), % hoist X drops crate Y on surface Z at place P
  ActionCost = 1,
  NextState = $s(ClearListNext,AvailNext,AtPredNext,OnPredNext,InPred,LiftRest).  
 
%(:action Lift
%:parameters (?x - hoist ?y - crate ?z - surface ?p - place)
%:precondition (and (at ?x ?p) (available ?x) (at ?y ?p) (on ?y ?z) (clear ?y))        
%:effect (and (not (at ?y ?p)) (lifting ?x ?y) (not (clear ?y)) (not (available ?x))   
%             (clear ?z) (not (on ?y ?z))))
action(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),NextState,Action,ActionCost),
  member([X|P],AtPred),  % at x p
  select(X,AvailList,AvailRest),   % available x
  select([Y|P],AtPred,AtPredRest), % at y p
  select([Y|Z],OnPred,OnPredRest), % on y z
  select(Y,ClearList,ClearRest)    % clear y
?=>
  LiftPredNext = insert_ordered(LiftPred,[X|Y]),
  ClearListNext = insert_ordered(ClearRest,Z),
  Action = $lift(X,Y,Z,P),
  ActionCost = 1,
  NextState = $s(ClearListNext,AvailRest,AtPredRest,OnPredRest,InPred,LiftPredNext).

      
%(:action Load                                                                         
%:parameters (?x - hoist ?y - crate ?z - truck ?p - place)                             
%:precondition (and (at ?x ?p) (at ?z ?p) (lifting ?x ?y))                             
%:effect (and (not (lifting ?x ?y)) (in ?y ?z) (available ?x)))                        
action(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),NextState,Action,ActionCost),
  truck(Z), % we need to state that Z is a truck - predicate At/2 do not separate hoists and trucks 
  member([X|P],AtPred),
  member([Z|P],AtPred),
  select([X|Y],LiftPred,LiftRest) % hoist X is lifting crate Y
?=>
  InPredNext = insert_ordered(InPred,[Y|Z]),
  AvailListNext = insert_ordered(AvailList,X),
  Action = $load(X,Y,Z,P),
  ActionCost = 1,
  NextState = $s(ClearList,AvailListNext,AtPred,OnPred,InPredNext,LiftRest).

%(:action Drive
%:parameters (?x - truck ?y - place ?z - place) 
%:precondition (and (at ?x ?y))
%:effect (and (not (at ?x ?y)) (at ?x ?z)))                                            
action(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),NextState,Action,ActionCost),
  truck(T), % we need to state explicitly that T is a truck - predicate At/2 do not separate hoists and trucks 
  select([T|L1],AtPred,AtPredRest),
  place(L2), % we need to choose another location
  L1 != L2
?=>
  AtPredNew = insert_ordered(AtPredRest,[T|L2]),
  Action = $drive(T,L1,L2),
  ActionCost = 1,
  NextState = $s(ClearList,AvailList,AtPredNew,OnPred,InPred,LiftPred).

%(:action Unload 
%:parameters (?x - hoist ?y - crate ?z - truck ?p - place)                             
%:precondition (and (at ?x ?p) (at ?z ?p) (available ?x) (in ?y ?z))                   
%:effect (and (not (in ?y ?z)) (not (available ?x)) (lifting ?x ?y)))                  
%)   
action(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),NextState,Action,ActionCost),
  % we do not need typing here - all object types are determined
  select(X,AvailList,AvailRest), % only hoist can be available
  member([X|P],AtPred),
  member([Z|P],AtPred),
  select([Y|Z],InPred,InPredRest) % only truck can contain something
?=>
  LiftNext = insert_ordered(LiftPred,[X|Y]),
  Action = $unload(X,Y,Z,P),
  ActionCost = 1,
  NextState = $s(ClearList,AvailRest,AtPred,OnPred,InPredRest,LiftNext).

main([Bench]) =>
  P = Bench.to_atom(),
  call(P).
