import planner.

solve_all =>
        all(Benches),nl,
        foreach(Bench in Benches)
                write(Bench), print(": "), once(call(Bench))
        end.

pddl(IFacts,GFacts) =>
    	initialize_table,
	PaletLocations = [Fact : Fact in IFacts,
				(Fact = $at(Palet,_),
				(	member($clear(Palet),IFacts);
				 	member($on(_,Palet),IFacts)
				),
				not member($on(Palet,_),IFacts))],	
	
	PalletLoc = [ [P|L] : Fact in IFacts,
				(Fact = $at(P,L),
				(	member($clear(P),IFacts);
				 	member($on(_,P),IFacts)
				),
				not member($on(P,_),IFacts))],	

	% do we need unary predicates in order to enable typing? 	
	% list of trucks 
	Trucks = [ $truck(T) : 	$at(T,_) in IFacts,
					(not member($on(_,T),IFacts),
					 not member($clear(T),IFacts),
					 not member($available(T),IFacts),
           				 not member($lifting(T,_),IFacts)
          				)
		],
  	% writeln(Trucks),
 	% list of places
	Places = remove_dups([ $place(P) : $at(_,P) in IFacts]),
  	% writeln(Places),
	% list of crates
  	Lifted = [ $crate(C) :  $lifting(_,C) in IFacts],
  	InTruck = [ $crate(C) : $in(C,_) in IFacts],
	InPile = [ $crate(C) :	$at(C,_) in IFacts,
					(not member($available(C),IFacts),
					 (member($on(C,_),IFacts);
					  member($in(C,_),IFacts)
					 )
					)
		],
  	Crates = Lifted++InTruck++InPile,
  	% writeln(Crates),
	% list of surfaces
	Surfaces = [ $surface(S) : Fact in PaletLocations++Crates,
				   (Fact = $at(S,_);
				    Fact = $crate(S)
				   )
		],


 	% fact lists
	AtPred = sort([ [L|P] : $at(L,P) in IFacts]),
	OnPred = sort([ [C|S] : $on(C,S) in IFacts]),
	InPred = sort([ [C|T] : $in(C,T) in IFacts]),	
	LiftPred = sort([ [H|C] : $lifting(H,C) in IFacts]), 
	ClearList = sort([ S : $clear(S) in IFacts]), 
	AvailList = sort([ H : $available(H) in IFacts]),

	OnPredGoal = [ [C|S] : $on(C,S) in GFacts],
	
	% load unary predicates and goal facts 
	cl_facts([$goal(GFacts)|Trucks++Places++Crates++Surfaces],[$goal(-),$truck(-),$place(-),$crate(-),$surface(-)]),
	cl_facts(GFacts,[]),	

	% crate final location list
	CFL = [],
	foreach($crate(X) in Crates, member([X|_],OnPredGoal)) % iterate only over crates which are to be moved between locations
		XBase = get_bottom(X,OnPredGoal),
		member([XBase|Loc],PalletLoc),
		CFL := [[X|Loc]|CFL]
	end,
%	writeln(CFL),
	cl_facts([$cfl(CFL)],[$cfl(-)]),	

%	printState($s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred)),
	statistics(runtime,RTB),
  ###PLANNER###($s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),99999,Plan,PlanCost),
	statistics(runtime,RTA),
 	printf("%d,%d!%n",PlanCost,RTA[2]).

final(_) ?=>
  Plan = current_plan(),
  current_resource_plan_cost(_Amount,Plan,Cost),
  if Cost == 0 then
    statistics(runtime,RT),
    printf("%d,%d;",Cost,RT[2]),flush(stdout)
  end,fail.

% final predicate
final(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred)), goal(Goal) =>
	% all predicates from GFacts has to be listed
	foreach(G in Goal)
		(
			(G = $on(C,S), member([C|S],OnPred));
			(G = $at(L,P), member([L|P],AtPred));
			(G = $in(C,T), member([C|T],InPred));
			(G = $lifting(H,C), member([H|C],LiftPred));
			(G = $available(H), member(H,AvailList));
			(G = $clear(S), member(S,ClearList))
		)
	end.
	
/* --------- debugging ------------- */
printState(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred)) =>
        printf("clear: "),
        writeln(ClearList),
        printf("avail: "),
    	writeln(AvailList),
        printf("at: "),
        writeln(AtPred),
        printf("on: "),
        writeln(OnPred),
        printf("in: "),
        writeln(InPred),
        printf("lifting: "),
        writeln(LiftPred).

%%%%%%% heuristic %%%%%%%%

% compute the lower bound for the number of steps to the goal
% for each wrongly placed crate, it is one step, if the crate is hold by a hoist
% otherwise we need two steps (pick up and drop off)
moves2go(OnPred,LiftPred) = sum(X) =>
	X = findall(Cost, ( on(X,Y),
                      not (member([X|Y],OnPred)),
                      simple_cost(X,LiftPred,Cost)
                    )
              ).
  

simple_cost(X,LiftPred,Cost),
    member([_H|X],LiftPred)
=>
  Cost = 1.

simple_cost(_X,_LiftPred,Cost)
=>
  Cost = 2.

testAction(State,Action) =>
  printf("======== current state =====\n"),
  printState(State),
  printf("======== next state ========\n"),
  action(State,NState,Action,_),
  printState(NState),
  printf("======== action ========\n"),
  writeln(Action),
  printf("========================\n").
/* ----------------------- */

%%%%%%% control rules %%%%%%%%
table
good_tower(Tower),
	Tower = [_]
=>
	true.

good_tower(Tower),
	Tower = [X,Y|T],
	(on(X,Y) ; (not on(X,_), not on(_,Y)))
=>
	good_tower([Y|T]).

% check if putting TopCrate on Surface results in good tower
check_good_tower(Surface,TopCrate,OnPred,ClearList) =>
  tower_up([get_bottom(Surface,OnPred)],OnPred,ClearList,T),
  good_tower([TopCrate|T]).

% check if there is a bad tower under Surface
check_bad_tower(Surface,OnPred,ClearList) =>
  tower_up([get_bottom(Surface,OnPred)],OnPred,ClearList,T),
  not good_tower(T).

% build a tower based on input data - starting from pallet
tower_up(T1@[X|_],OnPred,ClearList,T),
  member([Y|X],OnPred) =>
	tower_up([Y|T1],OnPred,ClearList,T).
tower_up(T@[X|_],OnPred,ClearList,T1),
  member(X,ClearList) =>
  	T1 = T.

% find bottom pallet for a given surface S using information about
% actual stacking
get_bottom(S,OnPred) = Pallet
  =>  if crate(S) then
        member([S|X],OnPred),
        Pallet = get_bottom(X,OnPred)
      elseif (surface(S),not crate(S)) then
        Pallet = S
      end.

% check if there is a hoist lifting some crate at Loc
loadedHoistAt(Loc,AtPred,LiftPred) =>
member([H|_],LiftPred),
member([H|Loc],AtPred).

% check if truck T contain some crate to be delivered at Loc
deliveringCrateTo(T,Loc,InPred),cfl(FL) =>
member([C|T],InPred),
member([C|Loc],FL).

%%%%%%% operators %%%%%%%%

%(:action Drop 
%:parameters (?x - hoist ?y - crate ?z - surface ?p - place)                           
%:precondition (and (at ?x ?p) (at ?z ?p) (clear ?z) (lifting ?x ?y))                  
%:effect (and (available ?x) (not (lifting ?x ?y)) (at ?y ?p) (not (clear ?z)) (clear ?y)
%                (on ?y ?z)))                                                          
action(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),NextState,Action,ActionCost),
  select([X|Y],LiftPred,LiftRest),
  member([X|P],AtPred),
  member([Z|P],AtPred),
  select(Z,ClearList,ClearRest),
  check_good_tower(Z,Y,OnPred,ClearList)
=>
  ClearListNext = insert_ordered(ClearRest,Y),
  AtPredNext = insert_ordered(AtPred,[Y|P]),
  OnPredNext = insert_ordered(OnPred,[Y|Z]),
  AvailNext = insert_ordered(AvailList,X),
  Action = $drop(X,Y,Z,P), % hoist X drops crate Y on surface Z at place P
  ActionCost = 1,
  NextState = $s(ClearListNext,AvailNext,AtPredNext,OnPredNext,InPred,LiftRest).  
 
%(:action Lift
%:parameters (?x - hoist ?y - crate ?z - surface ?p - place)
%:precondition (and (at ?x ?p) (available ?x) (at ?y ?p) (on ?y ?z) (clear ?y))        
%:effect (and (not (at ?y ?p)) (lifting ?x ?y) (not (clear ?y)) (not (available ?x))   
%             (clear ?z) (not (on ?y ?z))))
action(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),NextState,Action,ActionCost),
  member([X|P],AtPred),  % at x p
  select(X,AvailList,AvailRest),   % available x
  select([Y|P],AtPred,AtPredRest), % at y p
  select([Y|Z],OnPred,OnPredRest), % on y z
  check_bad_tower(Z,OnPred,ClearList),
  select(Y,ClearList,ClearRest)    % clear y
=>
  LiftPredNext = insert_ordered(LiftPred,[X|Y]),
  ClearListNext = insert_ordered(ClearRest,Z),
  Action = $lift(X,Y,Z,P),
  ActionCost = 1,
  NextState = $s(ClearListNext,AvailRest,AtPredRest,OnPredRest,InPred,LiftPredNext).

%(:action Unload 
%:parameters (?x - hoist ?y - crate ?z - truck ?p - place)                             
%:precondition (and (at ?x ?p) (at ?z ?p) (available ?x) (in ?y ?z))                   
%:effect (and (not (in ?y ?z)) (not (available ?x)) (lifting ?x ?y)))                  
%)   
action(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),NextState,Action,ActionCost),
  % we do not need typing here - all object types are determined
  select(X,AvailList,AvailRest), % only hoist can be available
  member([X|P],AtPred),
  member([Z|P],AtPred),
  select([Y|Z],InPred,InPredRest), % only truck can contain something

  member([Pal|P],AtPred),(surface(Pal), not crate(Pal)), % select pallet at P
  tower_up([Pal],OnPred,ClearList,T), % get tower on the pallet
  good_tower([Y|T])                   % Y can be put on top of the tower
=>
  LiftNext = insert_ordered(LiftPred,[X|Y]),
  Action = $unload(X,Y,Z,P),
  ActionCost = 1,
  NextState = $s(ClearList,AvailRest,AtPred,OnPred,InPredRest,LiftNext),
  moves2go(OnPred,LiftNext) < current_resource().

      
%(:action Load                                                                         
%:parameters (?x - hoist ?y - crate ?z - truck ?p - place)                             
%:precondition (and (at ?x ?p) (at ?z ?p) (lifting ?x ?y))                             
%:effect (and (not (lifting ?x ?y)) (in ?y ?z) (available ?x)))                        
action(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),NextState,Action,ActionCost),
  truck(Z), % we need to state that Z is a truck - predicate At/2 do not separate hoists and trucks 
  member([X|P],AtPred),
  member([Z|P],AtPred),
  select([X|Y],LiftPred,LiftRest) % hoist X is lifting crate Y
  ?=>
  InPredNext = insert_ordered(InPred,[Y|Z]),
  AvailListNext = insert_ordered(AvailList,X),
  Action = $load(X,Y,Z,P),
  ActionCost = 1,
  NextState = $s(ClearList,AvailListNext,AtPred,OnPred,InPredNext,LiftRest),
  moves2go(OnPred,LiftRest) < current_resource().

%(:action Drive
%:parameters (?x - truck ?y - place ?z - place) 
%:precondition (and (at ?x ?y))
%:effect (and (not (at ?x ?y)) (at ?x ?z)))                                            
action(s(ClearList,AvailList,AtPred,OnPred,InPred,LiftPred),NextState,Action,ActionCost),
  truck(T), % we need to state explicitly that T is a truck - predicate At/2 do not separate hoists and trucks 
  select([T|L1],AtPred,AtPredRest),
  (loadedHoistAt(L2,AtPred,LiftPred);deliveringCrateTo(T,L2,InPred)),
  L1 != L2
  ?=>
  AtPredNew = insert_ordered(AtPredRest,[T|L2]),
  Action = $drive(T,L1,L2),
  ActionCost = 1,
  NextState = $s(ClearList,AvailList,AtPredNew,OnPred,InPred,LiftPred),
  moves2go(OnPred,LiftPred) < current_resource().


main([Bench]) =>
  P = Bench.to_atom(),
  call(P).
